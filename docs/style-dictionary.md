# Style Dictionary

The project uses [Style Dictionary](https://styledictionary.com/) to manage design tokens.

Tokens are defined in the `src/styleD/tokens` folder.

The output styles are generated into the `src/styleD/build` folder.

We use rollup to copy the built styles into the `dist/styleD/build` folder during the build process, and these are published with the package.

Most tokens are generated from Figma variables using a script to make these available in the `src/styleD/tokens` folder. See the [Generate Design Tokens from Figma Variables](./scripts/figma/README.md) documentation for more details.

Use `pnpm build-styled` to generate the styles after making changes to the tokens and make sure to test and commit the changes to the built styles.

## Style Dictionary Structure

Style dictionary will take all the .json files in the `stand-component-library/src/styleD/tokens` folder and combines them into a single dictionary which has all the design tokens within.

Much of the output is based on how the JSON itself is structured.

To separate out styles that are "foundation" styles and "component" styles, we use the top level JSON key in each file to do this.

Foundation styles are split into "base" (also called "Primitives" within figma) and "semantic" keys, where "semantic" will have values which reference the "base"

So for `foundation.json` the JSON should start off with

```json
{
  "base": {...},
  "semantic": {...}
}
```

while for components it should be

```json
{
  "components": {...}
}
```

and further sublevels should be the corresponding foundation or component we're looking at, e.g. "colors" or "byline", inside if which is the individual design token

`foundations.json`

```json
{
  "base": {
    "colors": {...}
  },
  "semantic": {
    "colors": {...}
  },
}
```

`components/byline.json`

```json
{
  "components": {
    "byline": {...}
  }
}
```

Style dictionary will combine them into a single dictionary which looks like

```json
{
  "base": {
    "colors": {...}
  },
  "semantic": {
    "colors": {...}
  },
  "components": {
    "byline": {...}
  }
}
```

allowing us to have a separation of concerns regarding whats a foundation or whats a component by making sure we spit out different files for each.

We output to 3 files,

- `base` -> `base.css` and `base.ts`
- `semantic` -> `semantic.css` and `semantic.ts`
- `components` -> `components.css` and `components.ts`

This will allow a consumer to choose exactly what level of design they would need.

## Improving the Typescript export

Wwe make sure we only leave the `base` as a read only object (using `as const`), while exporting `semantic` and `components` as a normal object. We want to allow consumers to be able to override the values in `semantic` and `components` but not in `base`.

The corresponding types can then be generated by using `typeof` so we export those too.

This means we end up with something like the following:

`base.ts`

```ts
export const base = {
	colors: {
		neutral: {
			'0': '#000000',
			'7': '#121212',
			...
		},
		...
	},
} as const;

//	type Base = {
//		readonly colors: {
// 		readonly neutral: {
//				readonly '0': "#000000";
//				readonly '7': "#121212";
//				...
export type Base = typeof base;
```

`semantic.ts`

```ts
export const semantic = {
	colors: {
		text: {
			primary: '#000000',
		},
	},
};

//	type Semantic = {
//	    colors: {
// 	       text: {
//	            primary: string;
//	        };
//	    };
//	}
export type Semantic = typeof semantic;
```

`components.ts`

```ts
export const components = {
	byline: {
		color: '#000000',
	},
};
//	type Components = {
//	    byline: {
//	        color: string;
//	    };
//	}
export type Components = typeof components;
```
